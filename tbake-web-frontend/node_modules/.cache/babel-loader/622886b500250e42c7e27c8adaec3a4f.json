{"ast":null,"code":"import { Interface } from '@ethersproject/abi';\nimport { getWeb3NoAccount } from 'utils/web3';\nimport MultiCallAbi from 'config/abi/Multicall.json';\nimport { getMulticallAddress } from 'utils/addressHelpers';\n\nconst multicall = async (abi, calls, options = {}) => {\n  try {\n    const web3 = options.web3 || getWeb3NoAccount();\n    const multi = new web3.eth.Contract(MultiCallAbi, getMulticallAddress());\n    const itf = new Interface(abi);\n    const calldata = calls.map(call => [call.address.toLowerCase(), itf.encodeFunctionData(call.name, call.params)]);\n    const {\n      returnData\n    } = await multi.methods.aggregate(calldata).call(undefined, options.blockNumber);\n    const res = returnData.map((call, i) => itf.decodeFunctionResult(calls[i].name, call));\n    return res;\n  } catch (error) {\n    throw new Error(error);\n  }\n};\n/**\n * Multicall V2 uses the new \"tryAggregate\" function. It is different in 2 ways\n *\n * 1. If \"requireSuccess\" is false multicall will not bail out if one of the calls fails\n * 2. The return inclues a boolean whether the call was successful e.g. [wasSuccessfull, callResult]\n */\n\n\nexport const multicallv2 = async (abi, calls, options = {}) => {\n  const web3 = options.web3 || getWeb3NoAccount();\n  const multi = new web3.eth.Contract(MultiCallAbi, getMulticallAddress());\n  const itf = new Interface(abi);\n  const calldata = calls.map(call => [call.address.toLowerCase(), itf.encodeFunctionData(call.name, call.params)]);\n  const returnData = await multi.methods.tryAggregate(options.requireSuccess === undefined ? true : options.requireSuccess, calldata).call(undefined, options.blockNumber);\n  const res = returnData.map((call, i) => {\n    const [result, data] = call;\n    return {\n      result,\n      data: itf.decodeFunctionResult(calls[i].name, data)\n    };\n  });\n  return res;\n};\nexport default multicall;","map":{"version":3,"sources":["/Users/danialfajar/Downloads/tbake-web-staking-platform-master/src/utils/multicall.ts"],"names":["Interface","getWeb3NoAccount","MultiCallAbi","getMulticallAddress","multicall","abi","calls","options","web3","multi","eth","Contract","itf","calldata","map","call","address","toLowerCase","encodeFunctionData","name","params","returnData","methods","aggregate","undefined","blockNumber","res","i","decodeFunctionResult","error","Error","multicallv2","tryAggregate","requireSuccess","result","data"],"mappings":"AAEA,SAASA,SAAT,QAA0B,oBAA1B;AACA,SAASC,gBAAT,QAAiC,YAAjC;AACA,OAAOC,YAAP,MAAyB,2BAAzB;AACA,SAASC,mBAAT,QAAoC,sBAApC;;AAcA,MAAMC,SAAS,GAAG,OAAOC,GAAP,EAAmBC,KAAnB,EAAkCC,OAAyB,GAAG,EAA9D,KAAqE;AACrF,MAAI;AACF,UAAMC,IAAI,GAAGD,OAAO,CAACC,IAAR,IAAgBP,gBAAgB,EAA7C;AACA,UAAMQ,KAAK,GAAG,IAAID,IAAI,CAACE,GAAL,CAASC,QAAb,CAAsBT,YAAtB,EAA0DC,mBAAmB,EAA7E,CAAd;AACA,UAAMS,GAAG,GAAG,IAAIZ,SAAJ,CAAcK,GAAd,CAAZ;AAEA,UAAMQ,QAAQ,GAAGP,KAAK,CAACQ,GAAN,CAAWC,IAAD,IAAU,CAACA,IAAI,CAACC,OAAL,CAAaC,WAAb,EAAD,EAA6BL,GAAG,CAACM,kBAAJ,CAAuBH,IAAI,CAACI,IAA5B,EAAkCJ,IAAI,CAACK,MAAvC,CAA7B,CAApB,CAAjB;AACA,UAAM;AAAEC,MAAAA;AAAF,QAAiB,MAAMZ,KAAK,CAACa,OAAN,CAAcC,SAAd,CAAwBV,QAAxB,EAAkCE,IAAlC,CAAuCS,SAAvC,EAAkDjB,OAAO,CAACkB,WAA1D,CAA7B;AACA,UAAMC,GAAG,GAAGL,UAAU,CAACP,GAAX,CAAe,CAACC,IAAD,EAAOY,CAAP,KAAaf,GAAG,CAACgB,oBAAJ,CAAyBtB,KAAK,CAACqB,CAAD,CAAL,CAASR,IAAlC,EAAwCJ,IAAxC,CAA5B,CAAZ;AAEA,WAAOW,GAAP;AACD,GAVD,CAUE,OAAOG,KAAP,EAAc;AACd,UAAM,IAAIC,KAAJ,CAAUD,KAAV,CAAN;AACD;AACF,CAdD;AAgBA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,MAAME,WAAW,GAAG,OAAO1B,GAAP,EAAmBC,KAAnB,EAAkCC,OAAyB,GAAG,EAA9D,KAAqE;AAC9F,QAAMC,IAAI,GAAGD,OAAO,CAACC,IAAR,IAAgBP,gBAAgB,EAA7C;AACA,QAAMQ,KAAK,GAAG,IAAID,IAAI,CAACE,GAAL,CAASC,QAAb,CAAsBT,YAAtB,EAA0DC,mBAAmB,EAA7E,CAAd;AACA,QAAMS,GAAG,GAAG,IAAIZ,SAAJ,CAAcK,GAAd,CAAZ;AAEA,QAAMQ,QAAQ,GAAGP,KAAK,CAACQ,GAAN,CAAWC,IAAD,IAAU,CAACA,IAAI,CAACC,OAAL,CAAaC,WAAb,EAAD,EAA6BL,GAAG,CAACM,kBAAJ,CAAuBH,IAAI,CAACI,IAA5B,EAAkCJ,IAAI,CAACK,MAAvC,CAA7B,CAApB,CAAjB;AACA,QAAMC,UAAU,GAAG,MAAMZ,KAAK,CAACa,OAAN,CACtBU,YADsB,CACTzB,OAAO,CAAC0B,cAAR,KAA2BT,SAA3B,GAAuC,IAAvC,GAA8CjB,OAAO,CAAC0B,cAD7C,EAC6DpB,QAD7D,EAEtBE,IAFsB,CAEjBS,SAFiB,EAENjB,OAAO,CAACkB,WAFF,CAAzB;AAGA,QAAMC,GAAG,GAAGL,UAAU,CAACP,GAAX,CAAe,CAACC,IAAD,EAAOY,CAAP,KAAa;AACtC,UAAM,CAACO,MAAD,EAASC,IAAT,IAAiBpB,IAAvB;AACA,WAAO;AACLmB,MAAAA,MADK;AAELC,MAAAA,IAAI,EAAEvB,GAAG,CAACgB,oBAAJ,CAAyBtB,KAAK,CAACqB,CAAD,CAAL,CAASR,IAAlC,EAAwCgB,IAAxC;AAFD,KAAP;AAID,GANW,CAAZ;AAQA,SAAOT,GAAP;AACD,CAlBM;AAmBP,eAAetB,SAAf","sourcesContent":["import Web3 from 'web3'\nimport { AbiItem } from 'web3-utils'\nimport { Interface } from '@ethersproject/abi'\nimport { getWeb3NoAccount } from 'utils/web3'\nimport MultiCallAbi from 'config/abi/Multicall.json'\nimport { getMulticallAddress } from 'utils/addressHelpers'\n\ninterface Call {\n  address: string // Address of the contract\n  name: string // Function name on the contract (example: balanceOf)\n  params?: any[] // Function params\n}\n\ninterface MulticallOptions {\n  web3?: Web3\n  blockNumber?: number\n  requireSuccess?: boolean\n}\n\nconst multicall = async (abi: any[], calls: Call[], options: MulticallOptions = {}) => {\n  try {\n    const web3 = options.web3 || getWeb3NoAccount()\n    const multi = new web3.eth.Contract(MultiCallAbi as unknown as AbiItem, getMulticallAddress())\n    const itf = new Interface(abi)\n\n    const calldata = calls.map((call) => [call.address.toLowerCase(), itf.encodeFunctionData(call.name, call.params)])\n    const { returnData } = await multi.methods.aggregate(calldata).call(undefined, options.blockNumber)\n    const res = returnData.map((call, i) => itf.decodeFunctionResult(calls[i].name, call))\n\n    return res\n  } catch (error) {\n    throw new Error(error)\n  }\n}\n\n/**\n * Multicall V2 uses the new \"tryAggregate\" function. It is different in 2 ways\n *\n * 1. If \"requireSuccess\" is false multicall will not bail out if one of the calls fails\n * 2. The return inclues a boolean whether the call was successful e.g. [wasSuccessfull, callResult]\n */\nexport const multicallv2 = async (abi: any[], calls: Call[], options: MulticallOptions = {}) => {\n  const web3 = options.web3 || getWeb3NoAccount()\n  const multi = new web3.eth.Contract(MultiCallAbi as unknown as AbiItem, getMulticallAddress())\n  const itf = new Interface(abi)\n\n  const calldata = calls.map((call) => [call.address.toLowerCase(), itf.encodeFunctionData(call.name, call.params)])\n  const returnData = await multi.methods\n    .tryAggregate(options.requireSuccess === undefined ? true : options.requireSuccess, calldata)\n    .call(undefined, options.blockNumber)\n  const res = returnData.map((call, i) => {\n    const [result, data] = call\n    return {\n      result,\n      data: itf.decodeFunctionResult(calls[i].name, data),\n    }\n  })\n\n  return res\n}\nexport default multicall\n"]},"metadata":{},"sourceType":"module"}